*cleave.txt*    For Vim version 8.0

==============================================================================
CONTENTS                                     *cleave-contents*

  1. Introduction...................|cleave-introduction|
  2. Commands.......................|cleave-commands|
  3. Options........................|cleave-options|
  4. Examples.......................|cleave-examples|
  5. Requirements...................|cleave-requirements|

==============================================================================
INTRODUCTION                                 *cleave-introduction*

Vim-cleave is a plugin that splits a buffer's content vertically at a
specified column, creating separate left and right buffers while maintaining
spatial positioning. This is particularly useful for editing files with
distinct left and right content, such as diffs, documentation with
annotations, or formatted text.

Key features:
- Buffer splitting at any column position
- Text reflow with paragraph alignment preservation
- Spatial preservation of cursor position and scrolling
- Intelligent paragraph boundary detection

==============================================================================
COMMANDS                                     *cleave-commands*

*:CleaveAtCursor*
    Splits the current buffer at the cursor position. Creates two new buffers:
    - Left buffer: content from start of each line to cursor column
    - Right buffer: content from cursor column to end of each line
    
    The width of the new left window will be set to the cursor column.
    Both windows will have scroll binding enabled for synchronized scrolling.

*:CleaveAtColumn {column}*
    Splits the current buffer at the specified {column}. The width of the
    new left window will be set to {column}.
    
    Example: >
        :CleaveAtColumn 80
<
    This splits the buffer at column 80, useful for working with text that
    has a specific line length or format.

*:CleaveAgain*                               *cleave-again*
    Re-cleaves the current buffer at the most recently used cleave column for
    this buffer. The column is stored when `:CleaveAtCursor` or
    `:CleaveAtColumn` is used.

    This command works even if the current buffer has unsaved changes.

    Example: >
        :CleaveAgain
<
    This reopens the left/right split at the previous cleave column.

*:CleaveUndo*
    Restores the original buffer and closes the cleaved windows. This command
    discards any changes made to the split buffers and returns to the
    original buffer state.

*:CleaveJoin*
    Merges the left and right buffers back into the original buffer,
    maintaining proper alignment and spacing between the content. Changes
    made to either buffer are preserved in the merged result.
    
    The plugin calculates the necessary padding to maintain proper column
    alignment when joining the content.

*:CleaveReflow {width} [mode]*               *cleave-reflow*
    Reflows the text in the current buffer (left or right) to the specified
    {width}. Optionally pass {mode} (`ragged` or `justify`) to override the
    configured reflow mode. This command provides intelligent text wrapping
    while preserving the relationship between left and right content.

    Key features:
    - Automatically detects which cleaved buffer has focus
    - Handles both left and right buffer reflow with dedicated algorithms
    - Preserves paragraph alignment between buffers
    - Maintains correspondence of paragraph positions across buffers
    - Updates window sizing automatically when reflowing the left buffer
    - Uses content-based matching to track paragraph positions
    - Preserves original paragraph positioning when possible
    - Removes trailing whitespace during processing
    
    The algorithm works differently for left vs right buffers:
    
    For LEFT buffer reflow:
    1. Records paragraph positions in the RIGHT buffer
    2. Stores first words from LEFT buffer paragraphs for tracking
    3. Reflows the LEFT buffer text to new width
    4. Finds new paragraph positions by matching first words
    5. Realigns RIGHT buffer paragraphs to match new LEFT positions
    6. Updates window sizing to accommodate new LEFT buffer width
    
    For RIGHT buffer reflow:
    1. Identifies paragraph boundaries and content in RIGHT buffer
    2. Reflows each paragraph individually to new width
    3. Attempts to preserve original line positions when possible
    4. Ensures proper spacing between paragraphs
    5. LEFT buffer remains unchanged

    Minimum width: 10 characters

    Modes:
    - `ragged` leaves the right edge uneven (default)
    - `justify` distributes spaces to align the right edge, keeping the last
      line ragged unless `g:cleave_justify_last_line` is enabled.
    
    Example: >
        :CleaveReflow 60
        :CleaveReflow 60 justify
<
    This reflows the current buffer to 60 characters width while maintaining
    alignment with the corresponding buffer.

*:CleaveJustifyToggle*
    Toggles the active buffer's reflow mode between `ragged` and `justify`.

*:CleaveAlign*                               *cleave-align*
    Aligns right buffer paragraphs to match left buffer paragraph positions.
    This command is useful when paragraph alignment has been disrupted and
    needs to be restored.

    Key features:
    - Uses text properties to identify paragraph positions in the left buffer
    - Automatically creates text properties if they don't exist
    - Handles paragraph overlap conflicts by sliding paragraphs down
    - Maintains proper spacing between paragraphs
    - Provides feedback on actual paragraph placement

    The command performs the following steps:
    1. Retrieves paragraph start positions from left buffer text properties
    2. Extracts all paragraphs from the right buffer
    3. Attempts to place each paragraph at its corresponding left buffer position
    4. Resolves conflicts by sliding overlapping paragraphs down
    5. Ensures at least one blank line between paragraphs
    6. Reports the actual positions where paragraphs were placed

    Example: >
        :CleaveAlign
<
    This realigns the right buffer paragraphs to match the text property
    anchors placed thoughout the left buffer.

*:CleaveShiftParagraphUp*                    *cleave-shift-up*
    Moves the current paragraph up by one line in the active buffer and updates
    the left-side anchor markers. This is used to fine-tune paragraph placement.

    Notes:
    - Works in either left or right buffer
    - The other buffer is not moved
    - Movement stops if it would remove the single blank line between paragraphs
    - Paragraph anchor markers in the left buffer are refreshed after each move

    Example: >
        :CleaveShiftParagraphUp
<
    This shifts the paragraph under the cursor up by one line.

*:CleaveShiftParagraphDown*                  *cleave-shift-down*
    Moves the current paragraph down by one line in the active buffer and
    updates the left-side anchor markers. This is used to fine-tune paragraph
    placement.

    Notes:
    - Works in either left or right buffer
    - The other buffer is not moved
    - Movement stops if it would remove the single blank line between paragraphs
    - Paragraph anchor markers in the left buffer are refreshed after each move

    Example: >
        :CleaveShiftParagraphDown
<
    This shifts the paragraph under the cursor down by one line.

*:CleaveSetProps*                            *cleave-setprops*
    Creates or updates text properties that mark paragraph start positions
    in the left buffer. These text properties serve as anchors for paragraph
    alignment operations and are used by other cleave commands.
    
    This function is available but not to be manually called in regular use
    as it is called as needed by other functions. 

    For each paragraph in the right buffer, the first word in the
    corresponding line of the left buffer is wrapped with a text property
    to serve as an anchor. If that line is empty, a zero width property
    is added to the first column.  

    Removes existing properties before creating new ones
    Creates 'cleave_paragraph_start' text properties 

    Text properties created by this command are used by:
    - `:CleaveAlign` for paragraph positioning
    - `:CleaveReflow` for maintaining paragraph correspondence
    - `:CleaveToggleTextAnchorVis` for visual feedback

    Example: >
        :CleaveSetProps
<
    This creates text property anchors at all paragraph start positions
    in the current left buffer.

*:CleaveToggleTextAnchorVis*                 *cleave-toggle-anchors*
   
    Toggles the visual highlighting of paragraph start text properties between
    visible and invisible states. Intended for debugging to show the text 
    anchors in left buffer where notes in the right buffer will be aligned
    (the top line of each paragraph in right buffer will align with anchor in
    the left buffer). Note it is possible to have a text anchor on an empty 
    line. Those anchors will not be highlighted with this command. 
    
    Toggles between 'Normal' (invisible) and 'MatchParen' (visible) highlights

    Example: >
        :CleaveToggleTextAnchorVis
<
    This toggles paragraph anchor visibility, making it easy to see where
    paragraph alignment points are located in the left buffer.

==============================================================================
OPTIONS                                      *cleave-options*

*g:cleave_gutter*
    Sets the number of spaces between the left and right content when joining
    buffers with `:CleaveJoin`. This affects the spacing calculation and
    determines how much padding is added between the left and right content
    in the merged result.

    Default: `3`
    
    Example: >
        let g:cleave_gutter = 5
<

*g:cleave_reflow_mode*
    Default reflow mode used by `:CleaveReflow`. Values are `ragged` or
    `justify`.

    Default: `ragged`

    Example: >
        let g:cleave_reflow_mode = 'justify'
<

*g:cleave_hyphenate*
    Enable heuristic hyphenation when a single word exceeds the target width.

    Default: `1`

*g:cleave_dehyphenate*
    Join end-of-line hyphenations (`hy-` + `phen`) before reflowing a
    paragraph.

    Default: `1`

*g:cleave_hyphen_min_length*
    Minimum word length eligible for hyphenation.

    Default: `8`

*g:cleave_justify_last_line*
    When enabled, justify the final line of each paragraph.

    Default: `0`

==============================================================================
EXAMPLES                                     *cleave-examples*

Basic workflow: >
    " Position cursor at column 40 and split
    40|
    :CleaveAtCursor
    
    " Or split at a specific column
    :CleaveAtColumn 80
    
    " Reflow the left buffer to 60 characters
    :CleaveReflow 60

    " Realign paragraphs after changing left buffer
    :CleaveAlign

    " Shift a right paragraph to fine-tune alignment
    :CleaveShiftParagraphDown
    
    " Rejoin the left and right buffers back together
    :CleaveJoin
    
    " Or restore original buffer
    :CleaveUndo

==============================================================================
REQUIREMENTS                                 *cleave-requirements*

- Vim 8.0 or higher
- Text properties support (for advanced paragraph alignment features)
  Text properties are available in Vim 8.1+ and provide enhanced paragraph
  tracking during reflow operations.

==============================================================================
vim:tw=78:ts=8:ft=help:norl:
