*cleave.txt*    For Vim version 8.0

==============================================================================
CONTENTS                                     *cleave-contents*

  1. Introduction...................|cleave-introduction|
  2. Commands.......................|cleave-commands|
  3. Options........................|cleave-options|
  4. Modelines......................|cleave-modelines|
  5. Examples.......................|cleave-examples|
  6. Requirements...................|cleave-requirements|

==============================================================================
INTRODUCTION                                 *cleave-introduction*

Vim-cleave is a plugin that splits a buffer's content vertically at a
specified column, creating separate left and right buffers while maintaining
spatial positioning. This is particularly useful for editing files with
distinct left and right content, such as diffs, documentation with
annotations, or formatted text.

Key features:
- Buffer splitting at any column position
- Text reflow with paragraph alignment preservation
- Spatial preservation of cursor position and scrolling
- Intelligent paragraph boundary detection
- Modeline-driven settings for repeatable cleave sessions

==============================================================================
COMMANDS                                     *cleave-commands*

*:CleaveAtCursor*
    Splits the current buffer at the cursor position. Creates two new buffers:
    - Left buffer: content from start of each line to cursor column
    - Right buffer: content from cursor column to end of each line
    
    The width of the new left window will be set to the cursor column.
    Both windows will have scroll binding enabled for synchronized scrolling.

*:CleaveAtColumn {column}*
    Splits the current buffer at the specified {column}. The width of the
    new left window will be set to {column}.
    
    Example: >
        :CleaveAtColumn 80
<
    This splits the buffer at column 80, useful for working with text that
    has a specific line length or format.

*:CleaveAtColorColumn*
    Splits the current buffer at the first 'colorcolumn' value. This is
    a convenience command that reads the buffer's 'colorcolumn' option and
    uses it as the cleave column.

    Requires 'colorcolumn' to be set to a positive number.

    Example: >
        :set colorcolumn=80
        :CleaveAtColorColumn
<

*:CleaveAgain*                               *cleave-again*
    Re-cleaves the current buffer at the most recently used cleave column for
    this buffer. The column is stored when `:CleaveAtCursor` or
    `:CleaveAtColumn` is used.

    This command works even if the current buffer has unsaved changes.

    Example: >
        :CleaveAgain
<
    This reopens the left/right split at the previous cleave column.

*:CleaveUndo*
    Restores the original buffer and closes the cleaved windows. This command
    discards any changes made to the split buffers and returns to the
    original buffer state.

*:CleaveJoin*
    Merges the left and right buffers back into the original buffer,
    maintaining proper alignment and spacing between the content. Changes
    made to either buffer are preserved in the merged result.
    
    The plugin calculates the necessary padding to maintain proper column
    alignment when joining the content.

*:CleaveReflow {width} [mode]*               *cleave-reflow*
    Reflows the text in the current buffer (left or right) to the specified
    {width}. Optionally pass {mode} (`ragged` or `justify`) to override the
    configured reflow mode. This command provides intelligent text wrapping
    while preserving the relationship between left and right content.

    Key features:
    - Automatically detects which cleaved buffer has focus
    - Handles both left and right buffer reflow with dedicated algorithms
    - Preserves paragraph alignment between buffers
    - Maintains correspondence of paragraph positions across buffers
    - Updates window sizing automatically when reflowing the left buffer
    - Uses content-based matching to track paragraph positions
    - Preserves original paragraph positioning when possible
    - Removes trailing whitespace during processing
    
    The algorithm works differently for left vs right buffers:
    
    For LEFT buffer reflow:
    1. Records paragraph positions in the RIGHT buffer
    2. Stores first words from LEFT buffer paragraphs for tracking
    3. Reflows the LEFT buffer text to new width
    4. Finds new paragraph positions by matching first words
    5. Realigns RIGHT buffer paragraphs to match new LEFT positions
    6. Updates window sizing to accommodate new LEFT buffer width
    
    For RIGHT buffer reflow:
    1. Identifies paragraph boundaries and content in RIGHT buffer
    2. Reflows each paragraph individually to new width
    3. Attempts to preserve original line positions when possible
    4. Ensures proper spacing between paragraphs
    5. LEFT buffer remains unchanged

    Minimum width: 10 characters

    Modes:
    - `ragged` leaves the right edge uneven (default)
    - `justify` distributes spaces to align the right edge, keeping the last
      line ragged unless `g:cleave_justify_last_line` is enabled.
    
    Example: >
        :CleaveReflow 60
        :CleaveReflow 60 justify
<
    This reflows the current buffer to 60 characters width while maintaining
    alignment with the corresponding buffer.

*:CleaveJustifyToggle*
    Toggles the active buffer's reflow mode between `ragged` and `justify`.

*:CleaveAlign*                               *cleave-align*
    Aligns right buffer paragraphs to match left buffer anchor positions.
    This command is useful when paragraph alignment has been disrupted and
    needs to be restored.

    Key features:
    - Reads text property positions from the left buffer
    - Validates that there are enough properties for the paragraphs
    - Extracts right-buffer paragraphs using simple detection
    - Handles paragraph overlap conflicts by sliding paragraphs down
    - Pads right buffer to match left buffer length
    - Updates text properties to reflect final positions
    - Restores cursor position and calls `syncbind`

    The command performs the following steps:
    1. Reads `cleave_paragraph_start` text property positions from the left buffer
    2. If fewer properties than paragraphs, exits with a message
    3. Extracts right-buffer paragraphs (simple detection)
    4. Places each paragraph at its corresponding text property line
    5. Slides overlapping paragraphs down with blank separators
    6. Pads right buffer and updates text properties

    Example: >
        :CleaveAlign
<
    This realigns the right buffer paragraphs to match the text property
    anchors in the left buffer.

*:CleaveShiftParagraphUp*                    *cleave-shift-up*
    Moves the current paragraph up by one line in the active buffer and updates
    the left-side anchor markers. This is used to fine-tune paragraph placement.

    Notes:
    - Works in either left or right buffer
    - The other buffer is not moved
    - Movement stops if it would remove the single blank line between paragraphs
    - Paragraph anchor markers in the left buffer are refreshed after each move

    Example: >
        :CleaveShiftParagraphUp
<
    This shifts the paragraph under the cursor up by one line.

*:CleaveShiftParagraphDown*                  *cleave-shift-down*
    Moves the current paragraph down by one line in the active buffer and
    updates the left-side anchor markers. This is used to fine-tune paragraph
    placement.

    Notes:
    - Works in either left or right buffer
    - The other buffer is not moved
    - Movement stops if it would remove the single blank line between paragraphs
    - Paragraph anchor markers in the left buffer are refreshed after each move

    Example: >
        :CleaveShiftParagraphDown
<
    This shifts the paragraph under the cursor down by one line.

*:CleaveSetProps*                            *cleave-setprops*
    Creates or updates text properties that mark paragraph start positions
    in the left buffer. These text properties serve as anchors for paragraph
    alignment operations and are used by other cleave commands.
    
    This function is available but not to be manually called in regular use
    as it is called as needed by other functions. 

    For each paragraph in the right buffer, the first word in the
    corresponding line of the left buffer is wrapped with a text property
    to serve as an anchor. If that line is empty, a zero width property
    is added to the first column.  

    Removes existing properties before creating new ones
    Creates 'cleave_paragraph_start' text properties 

    Text properties created by this command are used by:
    - `:CleaveAlign` for paragraph positioning
    - `:CleaveReflow` for maintaining paragraph correspondence
    - `:CleaveToggleTextAnchorVis` for visual feedback

    Example: >
        :CleaveSetProps
<
    This creates text property anchors at all paragraph start positions
    in the current left buffer.

*:CleaveToggleTextAnchorVis*                 *cleave-toggle-anchors*
   
    Toggles the visual highlighting of paragraph start text properties between
    visible and invisible states. Intended for debugging to show the text 
    anchors in left buffer where notes in the right buffer will be aligned
    (the top line of each paragraph in right buffer will align with anchor in
    the left buffer). Note it is possible to have a text anchor on an empty 
    line. Those anchors will not be highlighted with this command. 
    
    Toggles between 'Normal' (invisible) and 'MatchParen' (visible) highlights

    Example: >
        :CleaveToggleTextAnchorVis
<
    This toggles paragraph anchor visibility, making it easy to see where
    paragraph alignment points are located in the left buffer.

*:CleaveDebug* [mode]                        *cleave-debug*
    Prints left-buffer text properties and right-buffer paragraph starts
    for debugging alignment issues. Output is via |echomsg| and can be
    reviewed with |:messages|.

    Modes:
    - `interleaved` (default) — Merges both lists by line number into a
      side-by-side display showing which lines have properties, paragraph
      starts, or both.
    - `sequential` — Shows text properties first, then paragraph starts
      as two separate lists.

    Example: >
        :CleaveDebug
        :CleaveDebug sequential
<

                                             *cleave-auto-sync*
Auto-sync behaviors ~

    When editing a cleaved buffer, several autocmds keep state in sync:

    |InsertLeave| on RIGHT buffer: Pads right buffer to match left buffer
    length and updates text properties.

    |InsertLeave| on LEFT buffer: Reads text property positions from the
    left buffer and repositions right-buffer paragraphs to match, then
    pads and updates text properties.

    |TextChanged| on RIGHT buffer: Detects paragraph deletions in
    normal mode. When the paragraph count decreases, orphaned text
    properties are removed from the left buffer and |:CleaveAlign| is
    called to reposition remaining paragraphs.

    These autocmds keep the text property anchors up to date so that
    subsequent |:CleaveAlign| or |:CleaveReflow| commands use the correct
    paragraph positions without requiring a manual |:CleaveSetProps| call.

==============================================================================
OPTIONS                                      *cleave-options*

*g:cleave_gutter*
    Sets the number of spaces between the left and right content when joining
    buffers with `:CleaveJoin`. This affects the spacing calculation and
    determines how much padding is added between the left and right content
    in the merged result.

    Default: `3`
    
    Example: >
        let g:cleave_gutter = 5
<

*g:cleave_reflow_mode*
    Default reflow mode used by `:CleaveReflow`. Values are `ragged` or
    `justify`.

    Default: `ragged`

    Example: >
        let g:cleave_reflow_mode = 'justify'
<

*g:cleave_hyphenate*
    Enable heuristic hyphenation when a single word exceeds the target width.

    Default: `1`

*g:cleave_dehyphenate*
    Join end-of-line hyphenations (`hy-` + `phen`) before reflowing a
    paragraph.

    Default: `1`

*g:cleave_hyphen_min_length*
    Minimum word length eligible for hyphenation.

    Default: `8`

*g:cleave_justify_last_line*
    When enabled, justify the final line of each paragraph.

    Default: `0`

*g:cleave_modeline*
    Controls how vim-cleave interacts with modelines in files. Modelines
    allow cleave settings to be embedded directly in a file so that the
    next time you open and cleave the file, the same settings are applied
    automatically.

    Values:
    - `read`   Read modeline on cleave start but never write it back.
               Settings from the modeline (or inferred defaults) are
               applied when cleaving. (default)
    - `update` Read modeline on cleave start AND write it back on
               `:CleaveJoin`. This keeps the modeline in sync with the
               current settings so the next cleave session is consistent.
    - `ignore` Skip modeline processing entirely. The cleave column is
               determined only by the cursor position or an explicit
               `:CleaveAtColumn` argument.

    Default: `read`

    Example: >
        let g:cleave_modeline = 'update'
<

==============================================================================
MODELINES                                    *cleave-modelines*

Vim-cleave can read and write a `vim:` modeline embedded in your file to
drive cleave settings automatically. This makes cleave sessions repeatable
across file opens without needing to remember column positions or options.

Modeline format: >
    vim: cc=91 tw=79 fdc=5 wm=3 ve=all
<
The modeline uses abbreviated option names to keep the line short so it
does not get split across left and right buffers.

                                             *cleave-modeline-settings*
Settings recognized by vim-cleave:

    `cc`   Cleave column (colorcolumn). The column at which the buffer is
           split into left and right sides.

    `tw`   Text width. Sets the left buffer's 'textwidth' used for reflow.

    `fdc`  Fold column. Sets the left buffer's 'foldcolumn' for readability.

    `wm`   Wrap margin / gutter. Sets `g:cleave_gutter`, the space between
           left text and right notes when joining.

    `ve`   Virtual edit. Sets 'virtualedit' for editing (typically `all`
           for the right buffer).

Any other options in the modeline (e.g., `ft=markdown`) are preserved
when the modeline is updated.

                                             *cleave-modeline-behavior*
Behavior on cleave start (~:CleaveAtCursor~, ~:CleaveAtColumn~):

    When `g:cleave_modeline` is not `ignore`:
    1. The first 5 and last 5 lines of the buffer are scanned for a
       `vim:` modeline.
    2. If a modeline is found, its settings are extracted and applied.
    3. If no modeline is found, settings are inferred from buffer options
       ('textwidth', 'foldcolumn', 'colorcolumn', 'wrapmargin').
    4. The `cc` value is used as the cleave column when no explicit column
       argument is given.

Behavior on join (~:CleaveJoin~):

    When `g:cleave_modeline` is `update`:
    1. Current settings (cleave column, textwidth, foldcolumn, gutter,
       virtualedit) are collected from the left and right buffers.
    2. If a modeline exists, it is updated in place. Non-cleave options
       are preserved.
    3. If no modeline exists, a new one is appended to the end of the
       file.
    4. The buffer's window-local options ('colorcolumn', 'foldcolumn')
       and global 'virtualedit' are set to match.

                                             *cleave-modeline-heuristics*
When no modeline is present, vim-cleave infers settings:

    `cc`   Prefers 'colorcolumn' if set to a number. Otherwise uses
           textwidth + wrapmargin. Falls back to 80.
    `tw`   Prefers existing 'textwidth'. Otherwise inferred from the
           average non-empty line length (capped at 79).
    `fdc`  Prefers existing 'foldcolumn'. Otherwise inferred from
           leading-indent variance (0 if uniform).
    `wm`   Prefers existing 'wrapmargin'. Otherwise uses `g:cleave_gutter`
           (default 3).
    `ve`   Defaults to `all`.

==============================================================================
EXAMPLES                                     *cleave-examples*

Basic workflow: >
    " Position cursor at column 40 and split
    40|
    :CleaveAtCursor
    
    " Or split at a specific column
    :CleaveAtColumn 80
    
    " Reflow the left buffer to 60 characters
    :CleaveReflow 60

    " Realign paragraphs after changing left buffer
    :CleaveAlign

    " Shift a right paragraph to fine-tune alignment
    :CleaveShiftParagraphDown
    
    " Rejoin the left and right buffers back together
    :CleaveJoin
    
    " Or restore original buffer
    :CleaveUndo

Modeline workflow: >
    " Enable modeline updates in your vimrc
    let g:cleave_modeline = 'update'

    " Open a file with a modeline at the end:
    "   vim: cc=91 tw=79 fdc=5 wm=3 ve=all

    " Cleave without specifying a column — cc=91 is used automatically
    :CleaveAtCursor

    " Reflow and edit as needed
    :CleaveReflow 65

    " Join — modeline is updated with new settings
    :CleaveJoin

    " Next time you open the file, CleaveAtCursor will use the
    " updated modeline settings automatically

==============================================================================
REQUIREMENTS                                 *cleave-requirements*

- Vim 8.0 or higher
- Text properties support (for advanced paragraph alignment features)
  Text properties are available in Vim 8.1+ and provide enhanced paragraph
  tracking during reflow operations.

==============================================================================
vim:tw=78:ts=8:ft=help:norl:
